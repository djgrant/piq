---
export const prerender = true;

import DocsLayout from "../../layouts/DocsLayout.astro";

const codeFromResolver = `<span class="syn-keyword">import</span> { piq } <span class="syn-keyword">from</span> <span class="syn-string">'piqit'</span>

<span class="syn-keyword">const</span> query = piq.from(posts)`;

const codeScan = `<span class="syn-comment">// Find all posts from 2024</span>
piq.from(posts).scan({ year: <span class="syn-string">'2024'</span> })

<span class="syn-comment">// Find a specific post</span>
piq.from(posts).scan({ year: <span class="syn-string">'2024'</span>, slug: <span class="syn-string">'hello-world'</span> })

<span class="syn-comment">// Find all posts (empty constraints)</span>
piq.from(posts).scan({})`;

const codeFilter = `piq.from(posts)
  .scan({ year: <span class="syn-string">'2024'</span> })
  .filter({ status: <span class="syn-string">'published'</span> })`;

const codeSelectVariadic = `.select(<span class="syn-string">'params.slug'</span>, <span class="syn-string">'params.year'</span>, <span class="syn-string">'frontmatter.title'</span>, <span class="syn-string">'body.html'</span>)
<span class="syn-comment">// Result: { slug: string; year: string; title: string; html: string }</span>`;

const codeSelectObject = `.select({
  postSlug: <span class="syn-string">'params.slug'</span>,
  postTitle: <span class="syn-string">'frontmatter.title'</span>,
  content: <span class="syn-string">'body.html'</span>
})
<span class="syn-comment">// Result: { postSlug: string; postTitle: string; content: string }</span>`;

const codeSelectWildcard = `.select(<span class="syn-string">'params.*'</span>)
<span class="syn-comment">// Result: { slug: string; year: string }  (all params fields)</span>

.select(<span class="syn-string">'params.*'</span>, <span class="syn-string">'frontmatter.*'</span>)
<span class="syn-comment">// Result: { slug, year, title, status, tags, ... }</span>`;

const codeExec = `<span class="syn-keyword">const</span> results = <span class="syn-keyword">await</span> piq.from(posts)
  .scan({ year: <span class="syn-string">'2024'</span> })
  .select(<span class="syn-string">'params.slug'</span>)
  .exec()
<span class="syn-comment">// results: Array&lt;{ slug: string }&gt;</span>`;

const codeSingle = `<span class="syn-comment">// Returns first result or undefined</span>
<span class="syn-keyword">const</span> post = <span class="syn-keyword">await</span> piq.from(posts)
  .scan({ year: <span class="syn-string">'2024'</span>, slug: <span class="syn-string">'hello-world'</span> })
  .select(<span class="syn-string">'params.slug'</span>, <span class="syn-string">'frontmatter.title'</span>)
  .single()
  .exec()

<span class="syn-comment">// Throws if no results</span>
<span class="syn-keyword">const</span> post = <span class="syn-keyword">await</span> piq.from(posts)
  .scan({ year: <span class="syn-string">'2024'</span>, slug: <span class="syn-string">'hello-world'</span> })
  .select(<span class="syn-string">'params.slug'</span>)
  .single()
  .execOrThrow()`;

const codeStream = `<span class="syn-keyword">for await</span> (<span class="syn-keyword">const</span> post <span class="syn-keyword">of</span> piq.from(posts).scan({}).select(<span class="syn-string">'params.slug'</span>).stream()) {
  console.log(post.slug)
}`;


---

<DocsLayout title="API Reference">
  <h1>API Reference</h1>

  <h2>piq.from()</h2>

  <p>Create a query builder from a resolver.</p>

  <pre><code set:html={codeFromResolver} /></pre>

  <hr />

  <h2>scan(constraints)</h2>

  <p>
    Finds items by pattern. This is your cheapest operation—it works at the collection level 
    without reading file contents.
  </p>

  <pre><code set:html={codeScan} /></pre>

  <p>
    For filesystem resolvers, scan leverages path structure. Constraints match the path 
    parameters defined in your resolver.
  </p>

  <hr />

  <h2>filter(constraints)</h2>

  <p>
    Narrows results by document-level criteria. Requires reading frontmatter from each item, 
    so use after scan has narrowed the set.
  </p>

  <pre><code set:html={codeFilter} /></pre>

  <p>
    Filter parameters match the frontmatter schema. Only items where all filter values match 
    are included.
  </p>

  <hr />

  <h2>select(...paths) / select(aliases)</h2>

  <p>
    Declares which fields to include in results. Required before <code>exec()</code>.
  </p>

  <h3>Variadic form</h3>

  <pre><code set:html={codeSelectVariadic} /></pre>

  <h3>Object form (aliasing)</h3>

  <pre><code set:html={codeSelectObject} /></pre>

  <h3>Wildcards</h3>

  <pre><code set:html={codeSelectWildcard} /></pre>

  <h3>Namespaces</h3>

  <p>For the <code>fileMarkdown</code> resolver:</p>

  <ul>
    <li><code>params</code> — extracted from path patterns (free, from scan)</li>
    <li><code>frontmatter</code> — YAML metadata (light I/O)</li>
    <li><code>body</code> — parsed content (heavy I/O)</li>
  </ul>

  <hr />

  <h2>exec()</h2>

  <p>Executes the query and returns all results as an array.</p>

  <pre><code set:html={codeExec} /></pre>

  <hr />

  <h2>single()</h2>

  <p>Returns a builder for single-result queries.</p>

  <pre><code set:html={codeSingle} /></pre>

  <hr />

  <h2>stream()</h2>

  <p>For large result sets, stream results instead of loading all into memory:</p>

  <pre><code set:html={codeStream} /></pre>

</DocsLayout>
